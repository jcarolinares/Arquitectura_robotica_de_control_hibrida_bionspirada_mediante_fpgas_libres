// Code generated by Icestudio 0.5.1n201120

`default_nettype none

module main #(
 parameter va65403 = 32,
 parameter v06bee0 = 32,
 parameter vc51771 = "backlegs.list",
 parameter v74d52b = 5,
 parameter v52e975 = "frontlegs.list",
 parameter v792294 = 0,
 parameter vfc3c52 = 0,
 parameter v2f9b6b = 255,
 parameter v1a82ae = 255,
 parameter vd31587 = 127,
 parameter v5595f1 = 127
) (
 input v356c10,
 input vclk,
 output [7:0] vac8d59,
 output v508682,
 output va3bdd0
);
 localparam p2 = v792294;
 localparam p3 = v2f9b6b;
 localparam p5 = v1a82ae;
 localparam p6 = vfc3c52;
 localparam p7 = v5595f1;
 localparam p8 = vd31587;
 localparam p9 = vc51771;
 localparam p10 = v52e975;
 localparam p15 = v06bee0;
 localparam p16 = va65403;
 localparam p18 = v74d52b;
 wire w0;
 wire w1;
 wire w4;
 wire [0:7] w11;
 wire [0:7] w12;
 wire [0:7] w13;
 wire [0:7] w14;
 wire w17;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire [0:7] w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 assign v508682 = w1;
 assign va3bdd0 = w4;
 assign w20 = v356c10;
 assign vac8d59 = w24;
 assign w25 = vclk;
 assign w26 = vclk;
 assign w27 = vclk;
 assign w28 = vclk;
 assign w29 = vclk;
 assign w30 = vclk;
 assign w31 = vclk;
 assign w32 = vclk;
 assign w14 = w13;
 assign w23 = w22;
 assign w24 = w13;
 assign w24 = w14;
 assign w26 = w25;
 assign w27 = w25;
 assign w27 = w26;
 assign w28 = w25;
 assign w28 = w26;
 assign w28 = w27;
 assign w29 = w25;
 assign w29 = w26;
 assign w29 = w27;
 assign w29 = w28;
 assign w30 = w25;
 assign w30 = w26;
 assign w30 = w27;
 assign w30 = w28;
 assign w30 = w29;
 assign w31 = w25;
 assign w31 = w26;
 assign w31 = w27;
 assign w31 = w28;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w25;
 assign w32 = w26;
 assign w32 = w27;
 assign w32 = w28;
 assign w32 = w29;
 assign w32 = w30;
 assign w32 = w31;
 v70ff7f v1f18fe (
  .vef4cea(w0),
  .vb55943(w19),
  .vc24d9f(w22)
 );
 v3e6c24 v743d89 (
  .v608bd9(w0)
 );
 v589d01 #(
  .v79a04d(p2),
  .v65ff05(p3),
  .vc78345(p8)
 ) v595804 (
  .v8aec2f(w1),
  .v3984b5(w11),
  .v4e3a3a(w22),
  .vc27e17(w25)
 );
 v589d01 #(
  .v65ff05(p5),
  .v79a04d(p6),
  .vc78345(p7)
 ) v794826 (
  .v8aec2f(w4),
  .v3984b5(w12),
  .v4e3a3a(w23),
  .vc27e17(w26)
 );
 vd8154c #(
  .vb6979d(p9)
 ) v9e9dee (
  .v8a6470(w11),
  .v829be6(w13),
  .vf85857(w27)
 );
 vd8154c #(
  .vb6979d(p10)
 ) v192fe5 (
  .v8a6470(w12),
  .v829be6(w14),
  .vf85857(w28)
 );
 vd014cb #(
  .v5e4a03(p15)
 ) v0e83b0 (
  .vb86fe4(w13),
  .v7c533e(w17),
  .vdd729a(w29)
 );
 vebfed3 #(
  .vfb06ae(p16)
 ) v0b9bb3 (
  .v2a8434(w17),
  .vac0eb2(w30)
 );
 v56885a #(
  .v187a47(p18)
 ) vac3f19 (
  .va9e2af(w19),
  .v6e1dd1(w21),
  .v5688a8(w31)
 );
 v2107ac v611832 (
  .vd9601b(w20),
  .v64879c(w21),
  .vbbbce8(w32)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v70ff7f (
 input vb55943,
 input vef4cea,
 output vc24d9f
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vef4cea;
 assign w1 = vb55943;
 assign vc24d9f = w2;
 v70ff7f_v526aa2 v526aa2 (
  .d(w0),
  .clk(w1),
  .q(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Flip-flop D  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Delay flip-flop
/*-------------------------------------------------*/

module v70ff7f_v526aa2 (
 input clk,
 input d,
 output q
);
 // D flip-flop
 
 reg q = 1'b0;
 
 always @(posedge clk)
 begin
   q <= d;
 end
 
 
endmodule

module v3e6c24 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 v3e6c24_v68c173 v68c173 (
  .v(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- Bit 1  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Assign 1 to the output wire
/*-------------------------------------------------*/

module v3e6c24_v68c173 (
 output v
);
 // Bit 1
 
 assign v = 1'b1;
endmodule

module v589d01 #(
 parameter v79a04d = 8'h00,
 parameter v65ff05 = 8'hFF,
 parameter vc78345 = 8'h7F
) (
 input vc27e17,
 input [0:7] v3984b5,
 input v4e3a3a,
 output v8aec2f
);
 localparam p1 = v65ff05;
 localparam p2 = v79a04d;
 localparam p3 = vc78345;
 wire w0;
 wire w4;
 wire w5;
 wire [0:7] w6;
 assign v8aec2f = w0;
 assign w4 = vc27e17;
 assign w5 = v4e3a3a;
 assign w6 = v3984b5;
 v589d01_v815aa1 #(
  .in_max_angle(p1),
  .in_min_angle(p2),
  .in_home_pos(p3)
 ) v815aa1 (
  .servo(w0),
  .clk(w4),
  .enable_mov(w5),
  .bitpos(w6)
 );
endmodule

/*-------------------------------------------------*/
/*-- two_pos_servo_with_home  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- An improved version of the servo bit 180 block with position parameters and a home position
/*-------------------------------------------------*/

module v589d01_v815aa1 #(
 parameter in_min_angle = 0,
 parameter in_max_angle = 0,
 parameter in_home_pos = 0
) (
 input clk,
 input [7:0] bitpos,
 input enable_mov,
 output servo
);
 //-- ServoBit-180
 
 //-- Control de un servo Futaba 3003
 //-- con un bit. Se mueve a dos posiciones
 //-- Si enable movement está 0, el servo se mantiene en la posición "home_pos"
 //-- que se corresonden con 0 / 1
 //-- El angulo total recorrido es de 180 grados
 
 //-- ENTRADAS:
 //--  clk: Señal del sistema (12Mhz)
 //--  bitpos: Bit de posicion (0 - posicion derecha, 1 - posicion izquierda)
      
 //   Bitpos 0   Bitpos 1
 //    ___          ___
 //   | o---->  <----o |
 //   |   |        |   |
 //   |___|        |___|
 
 //-- SALIDAS:
 //-- servo : Señal PWM para controlar el servo
 
 //-- Constantes para el angulo DEL servo
 localparam ANG_0   = 8'h01;
 localparam ANG_45=8'h39;
 localparam ANG_90 = 8'h5F;
 localparam ANG_135=8'hAB;
 localparam ANG_180=8'hE0;
 localparam ANG_120=8'h5F;
 
 parameter min_angle =in_min_angle;
 parameter max_angle =in_max_angle;
 parameter home_pos=in_home_pos;
 
 //-- Posicion del servo cuando el
 //-- bit de entrada es 0
 //-- La corona del servo mira a la derecha
 localparam BIT0 = min_angle;
 
 //-- Posicion el servo cuando el BIT
 //-- de entrada es 1
 //-- La corona del servo mira a la izquierda
 localparam BIT1 = max_angle;
 
 //--Posicion del servo neutra o home
 localparam BITH=home_pos;
 
 
 //-- Posicion de 8 bits del servo
 reg [7:0] pos;
 
 //-- Asignar la posicion de 8 bits
 //-- segun si lo recibido es 0 ó 1 o segun si el enable_mov está activado
 always @(posedge clk)
     begin
     if (enable_mov ==0)
         begin
            pos<=BITH;
         end   
     else if (bitpos>BIT1)
         begin
            pos<=BIT1;
         end
     else if (bitpos<BIT0)
         begin
            pos<=BIT0;
         end
     else
         begin
            pos<=bitpos;
         end
     end
 
 
 //always @(posedge clk)
 //  begin//pos <= bitpos ? BIT1 : BIT0;
 //    if (enable_mov ==0)
 //       pos<=BITH;
 //    else if (bitpos==0)
 //       pos<=BIT0;
 //    else
 //       pos<=BIT1;
 //  end  
   
 //---
 //--- ServoMotor 
 
 //-- M es el valor del divisor para
 //-- obtener tics de M / 12.0 micro-segundos
 localparam M = 94; 
 localparam N = $clog2(M);
 
 //-- Contador para generar los tics
 reg [N-1:0] divcounter = 0;
 
 //-- Flag para indicar que un tic
 //-- ha ocurrido
 reg tic = 0;
 
 //-- Generacion de los tics. Cada
 //-- M ciclos del reloj se genera 1
 always @(posedge clk)
  tic <= (divcounter == M - 2);
 
 //-- Contador modulo M
 always @(posedge clk)
  if (tic)
    divcounter <= 0;
  else
    divcounter <= divcounter + 1;
 
 //-- Contador de la posicion del 
 //-- servo
 reg [10:0] angle_counter = 0;
 
 //-- A la posicion destino hay que
 //-- sumarle un offset, correspondiente
 //-- a los 0.3ms de la posicion inicial
 wire [8:0] pose = {1'b0, pos} + 9'd46;
 
 //-- Con cada tic se incrementa el
 //-- contador de angulo del servo
 always @(posedge clk)
  if (tic)
    angle_counter <= angle_counter + 1;
 
 //-- Cuando el contador es menor que el 
 //-- valor objetivo, la señal de PWM
 //-- del servo se pone 1, y 0 en 
 //-- caso contrario
 
 reg servo;
 
 always @(posedge clk) begin
  servo <= (angle_counter < {2'b00, pose});
  end
 
 
 
 
endmodule

module vd8154c #(
 parameter vb6979d = "romlist0.list"
) (
 input vf85857,
 input [7:0] v829be6,
 output [7:0] v8a6470
);
 localparam p0 = vb6979d;
 wire w1;
 wire [0:7] w2;
 wire [0:7] w3;
 assign w1 = vf85857;
 assign v8a6470 = w2;
 assign w3 = v829be6;
 vd8154c_vc1ab3d #(
  .ROMFILE(p0)
 ) vc1ab3d (
  .clk(w1),
  .D(w2),
  .A(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Rom_32x8  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- A rom of 8 bits and 32 positions
/*-------------------------------------------------*/

module vd8154c_vc1ab3d #(
 parameter ROMFILE = 0
) (
 input clk,
 input [7:0] A,
 output [7:0] D
);
 
 //-- ROM memory
 reg [7:0] rom [0:31];
 
 //-- Address bus (4 bits)
 wire [7:0] A;
 
 //-- Data bus (8 bits)
 reg [7:0] D;
 
 always @(negedge clk) begin
   D <= rom[A];
 end
 
 
 //-- Memory contents read
 //-- from the ROMFILE file
 initial begin
     if (ROMFILE) $readmemh(ROMFILE, rom);
 end
 
endmodule

module vd014cb #(
 parameter v5e4a03 = 256
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [7:0] vb86fe4,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vb86fe4 = w5;
 vd014cb_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

/*-------------------------------------------------*/
/*-- Contador-8bits-up-rst  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Contador módulo M, ascendente, de 8 bits, con reset 
/*-------------------------------------------------*/

module vd014cb_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [7:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 8; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 0;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule

module vebfed3 #(
 parameter vfb06ae = 1
) (
 input vac0eb2,
 output v2a8434
);
 localparam p2 = vfb06ae;
 wire w0;
 wire w1;
 assign v2a8434 = w0;
 assign w1 = vac0eb2;
 vebfed3_v6cac2f #(
  .HZ(p2)
 ) v6cac2f (
  .o(w0),
  .clk(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- Corazon-tic-Hz  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Corazón de bombeo de tics a un frecuencia parametrica en Hz
/*-------------------------------------------------*/

module vebfed3_v6cac2f #(
 parameter HZ = 0
) (
 input clk,
 output o
);
 //localparam HZ;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule

module v56885a #(
 parameter v187a47 = 1
) (
 input v5688a8,
 input v6e1dd1,
 output veabfb2,
 output va9e2af
);
 localparam p0 = v187a47;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w1 = v6e1dd1;
 assign veabfb2 = w2;
 assign va9e2af = w3;
 assign w4 = v5688a8;
 v56885a_v3140f5 #(
  .SEG(p0)
 ) v3140f5 (
  .start(w1),
  .p(w2),
  .tic(w3),
  .clk(w4)
 );
endmodule

/*-------------------------------------------------*/
/*-- timer-sec  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Temporizador en segundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar
/*-------------------------------------------------*/

module v56885a_v3140f5 #(
 parameter SEG = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //localparam SEC;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el corazon
 wire rst_heart;
 
 //-- Overflow del temporizador del corazon
 wire ov_heart;
 
 //-- Habilitacion del corazon
 wire ena;
 
 //-- Tics del corazon
 wire tic_heart;
 
 //-- Contador del corazon
 reg [N-1:0] heart=0;
 
 always @(posedge clk)
   if (rst_heart)
     heart <= 0;
   else
     heart <= heart + 1;
 
 //-- Overflow del contador
 assign ov_heart = (heart == M-1);
 
 //-- La salida del corazon es la señal de overflow
 assign tic_heart = ov_heart;
 
 //-- Reset del corazon
 assign rst_heart =~ena | ov_heart;
 
 
 
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 reg [7:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
 if (rst)
   counter <= 0;
 else
   if (tic_heart)
     counter <= counter + 1;
 
 //-- Evento: cuenta máxima de tics alcanzada
 assign ov = (counter == SEG);
 
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 assign ena = ~rst;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
 
endmodule

module v2107ac (
 input vbbbce8,
 input vd9601b,
 output v157a67,
 output v64879c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = vd9601b;
 assign v64879c = w1;
 assign w2 = vbbbce8;
 assign v157a67 = w3;
 v2107ac_v297cb2 v297cb2 (
  .d(w0),
  .tic(w1),
  .clk(w2),
  .state(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Pulsador-tic  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador
/*-------------------------------------------------*/

module v2107ac_v297cb2 (
 input clk,
 input d,
 output state,
 output tic
);
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d2;
 reg r_in;
 
 always @(posedge clk)
  d2 <= d;
  
 always @(posedge clk)
   r_in <= d2;
 
 
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ r_in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= r_in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 //-- Generar tic en flanco de subida del boton
 reg old;
 
 always @(posedge clk)
   old <= btn_out_r;
   
 assign tic = !old & btn_out_r;
 
 //-- El estado del pulsador se saca por state
 assign state = btn_out_r;
 
 
endmodule
