// Code generated by Icestudio 0.5.1n201120

`default_nettype none

module main #(
 parameter v9d205c = 8'd5,
 parameter v18f02c = 8'd5,
 parameter vdbb7fe = 8'd127,
 parameter vf2d9d8 = 8'd127,
 parameter v9200c1 = 8'd5,
 parameter vb2f8f2 = 8'h55,
 parameter v6ba809 = 8'h6a,
 parameter v724468 = 8'd127,
 parameter vf84345 = 8'haa,
 parameter vfca1f4 = 200_000,
 parameter v434ab1 = 8'h95,
 parameter v607c1a = 8'h55,
 parameter v20339f = 200_000,
 parameter v52b919 = 8'haa,
 parameter v89458e = 200_000,
 parameter vd4ccc6 = 8'h6a,
 parameter v543f4e = 8'h6a,
 parameter vba1e6b = 8'd100,
 parameter v2045ba = 0,
 parameter va4b43a = 0,
 parameter v65f0c8 = 0,
 parameter v71b047 = 0,
 parameter vfa9136 = 255,
 parameter vf916e7 = 255,
 parameter v8f3685 = 255,
 parameter v138e59 = 255,
 parameter va495fa = 8'd0,
 parameter v92b421 = 8'd235,
 parameter v9534e4 = 8'd0,
 parameter v174936 = 8'd0,
 parameter v965093 = 127,
 parameter vdc7128 = 127,
 parameter v30301a = 127,
 parameter vfbfb50 = 127
) (
 input vc17dbe,
 input v145b8e,
 input vclk,
 output vb834f3,
 output vfd9349,
 output vbde3ff,
 output vb2ca51,
 output [0:7] vinit
);
 localparam p0 = va4b43a;
 localparam p1 = vf916e7;
 localparam p2 = v92b421;
 localparam p3 = vdc7128;
 localparam p5 = v89458e;
 localparam p6 = v724468;
 localparam p7 = v607c1a;
 localparam p8 = v52b919;
 localparam p14 = v9200c1;
 localparam p18 = v65f0c8;
 localparam p19 = v8f3685;
 localparam p20 = v9534e4;
 localparam p21 = v30301a;
 localparam p23 = v71b047;
 localparam p24 = v138e59;
 localparam p25 = v174936;
 localparam p26 = vfbfb50;
 localparam p27 = vba1e6b;
 localparam p29 = v2045ba;
 localparam p30 = vfa9136;
 localparam p31 = va495fa;
 localparam p32 = v965093;
 localparam p33 = v543f4e;
 localparam p34 = vfca1f4;
 localparam p35 = vdbb7fe;
 localparam p36 = vb2f8f2;
 localparam p37 = vf84345;
 localparam p44 = v9d205c;
 localparam p46 = vd4ccc6;
 localparam p50 = v20339f;
 localparam p51 = vf2d9d8;
 localparam p52 = v6ba809;
 localparam p53 = v434ab1;
 localparam p59 = v18f02c;
 wire w4;
 wire w9;
 wire w10;
 wire [0:7] w11;
 wire [0:7] w12;
 wire [0:7] w13;
 wire [0:7] w15;
 wire [0:7] w16;
 wire w17;
 wire w22;
 wire w28;
 wire w38;
 wire w39;
 wire [0:7] w40;
 wire [0:7] w41;
 wire [0:7] w42;
 wire [0:7] w43;
 wire [0:7] w45;
 wire [0:7] w47;
 wire w48;
 wire w49;
 wire w54;
 wire [0:7] w55;
 wire [0:7] w56;
 wire [0:7] w57;
 wire [0:7] w58;
 wire [0:7] w60;
 wire w61;
 wire w62;
 wire w63;
 wire w64;
 wire w65;
 wire w66;
 wire w67;
 wire w68;
 wire w69;
 wire w70;
 assign vb834f3 = w4;
 assign w9 = vc17dbe;
 assign vfd9349 = w17;
 assign vbde3ff = w22;
 assign vb2ca51 = w28;
 assign w38 = v145b8e;
 assign w64 = vclk;
 assign w65 = vclk;
 assign w66 = vclk;
 assign w67 = vclk;
 assign w68 = vclk;
 assign w69 = vclk;
 assign w70 = vclk;
 assign w65 = w64;
 assign w66 = w64;
 assign w66 = w65;
 assign w67 = w64;
 assign w67 = w65;
 assign w67 = w66;
 assign w68 = w64;
 assign w68 = w65;
 assign w68 = w66;
 assign w68 = w67;
 assign w69 = w64;
 assign w69 = w65;
 assign w69 = w66;
 assign w69 = w67;
 assign w69 = w68;
 assign w70 = w64;
 assign w70 = w65;
 assign w70 = w66;
 assign w70 = w67;
 assign w70 = w68;
 assign w70 = w69;
 v725b7e v947fca (
  .v9fb85f(w62)
 );
 v98655f #(
  .v79a04d(p0),
  .v65ff05(p1),
  .vee4e49(p2),
  .vc78345(p3)
 ) v63a490 (
  .v8aec2f(w4),
  .v3984b5(w16),
  .v4e3a3a(w62),
  .vc27e17(w64)
 );
 v2003b1 #(
  .veca477(p5)
 ) v5fe3be (
  .v22d3e8(w10),
  .vc04c2e(w65)
 );
 v36d45a #(
  .vc5c8ea(p6)
 ) v5032e2 (
  .v7d356d(w11)
 );
 v36d45a #(
  .vc5c8ea(p7)
 ) v17d01e (
  .v7d356d(w12)
 );
 v36d45a #(
  .vc5c8ea(p8)
 ) vafca74 (
  .v7d356d(w13)
 );
 va1b138 v18f4ec (
  .v26bbef(w9),
  .v21a20e(w10),
  .v80e965(w11),
  .v8071e6(w12),
  .v9ec8c5(w13),
  .v71e3cf(w15),
  .vcff1aa(w16)
 );
 v36d45a #(
  .vc5c8ea(p14)
 ) v64fc33 (
  .v7d356d(w15)
 );
 v725b7e v49b838 (
  .v9fb85f(w48)
 );
 v98655f #(
  .v79a04d(p18),
  .v65ff05(p19),
  .vee4e49(p20),
  .vc78345(p21)
 ) v7e3a94 (
  .v8aec2f(w17),
  .v3984b5(w47),
  .v4e3a3a(w48),
  .vc27e17(w66)
 );
 v725b7e ve16a01 (
  .v9fb85f(w63)
 );
 v98655f #(
  .v79a04d(p23),
  .v65ff05(p24),
  .vee4e49(p25),
  .vc78345(p26)
 ) vc3b378 (
  .v8aec2f(w22),
  .v3984b5(w45),
  .v4e3a3a(w63),
  .vc27e17(w67)
 );
 v36d45a #(
  .vc5c8ea(p27)
 ) vff96a6 (
 
 );
 v725b7e v6ec8dd (
  .v9fb85f(w49)
 );
 v98655f #(
  .v79a04d(p29),
  .v65ff05(p30),
  .vee4e49(p31),
  .vc78345(p32)
 ) v9f7c19 (
  .v8aec2f(w28),
  .v4e3a3a(w49),
  .v3984b5(w60),
  .vc27e17(w68)
 );
 v36d45a #(
  .vc5c8ea(p33)
 ) vdbaf1b (
 
 );
 v2003b1 #(
  .veca477(p34)
 ) v58c845 (
  .v22d3e8(w39),
  .vc04c2e(w69)
 );
 v36d45a #(
  .vc5c8ea(p35)
 ) v94ab60 (
  .v7d356d(w40)
 );
 v36d45a #(
  .vc5c8ea(p36)
 ) vbfee57 (
  .v7d356d(w41)
 );
 v36d45a #(
  .vc5c8ea(p37)
 ) vec29d3 (
  .v7d356d(w42)
 );
 va1b138 v4f66d8 (
  .v26bbef(w38),
  .v21a20e(w39),
  .v80e965(w40),
  .v8071e6(w41),
  .v9ec8c5(w42),
  .v71e3cf(w43),
  .vcff1aa(w45)
 );
 v36d45a #(
  .vc5c8ea(p44)
 ) v629073 (
  .v7d356d(w43)
 );
 v36d45a #(
  .vc5c8ea(p46)
 ) v322b79 (
  .v7d356d(w47)
 );
 v2003b1 #(
  .veca477(p50)
 ) v5e196a (
  .v22d3e8(w54),
  .vc04c2e(w70)
 );
 v36d45a #(
  .vc5c8ea(p51)
 ) v876682 (
  .v7d356d(w55)
 );
 v36d45a #(
  .vc5c8ea(p52)
 ) v848c0d (
  .v7d356d(w56)
 );
 v36d45a #(
  .vc5c8ea(p53)
 ) vae8b7b (
  .v7d356d(w57)
 );
 va1b138 v4f9eb7 (
  .v21a20e(w54),
  .v80e965(w55),
  .v8071e6(w56),
  .v9ec8c5(w57),
  .v71e3cf(w58),
  .vcff1aa(w60),
  .v26bbef(w61)
 );
 v36d45a #(
  .vc5c8ea(p59)
 ) v983885 (
  .v7d356d(w58)
 );
 v21cfcc vc789d2 (
  .v9fb85f(w61)
 );
 assign vinit = 8'b00000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- 1  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Un bit constante a 1
/*-------------------------------------------------*/

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule

module v98655f #(
 parameter v79a04d = 8'h00,
 parameter v65ff05 = 8'hFF,
 parameter vee4e49 = 8'h00,
 parameter vc78345 = 8'h7F
) (
 input vc27e17,
 input [0:7] v3984b5,
 input v4e3a3a,
 output v8aec2f
);
 localparam p1 = v65ff05;
 localparam p2 = v79a04d;
 localparam p3 = vc78345;
 localparam p7 = vee4e49;
 wire w0;
 wire w4;
 wire w5;
 wire [0:7] w6;
 assign v8aec2f = w0;
 assign w4 = vc27e17;
 assign w5 = v4e3a3a;
 assign w6 = v3984b5;
 v98655f_v815aa1 #(
  .in_max_angle(p1),
  .in_min_angle(p2),
  .in_home_pos(p3),
  .in_trim(p7)
 ) v815aa1 (
  .servo(w0),
  .clk(w4),
  .enable_mov(w5),
  .bitpos(w6)
 );
endmodule

/*-------------------------------------------------*/
/*-- two_pos_servo_with_home  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- An improved version of the servo bit 180 block with position parameters and a home position
/*-------------------------------------------------*/

module v98655f_v815aa1 #(
 parameter in_min_angle = 0,
 parameter in_max_angle = 0,
 parameter in_trim = 0,
 parameter in_home_pos = 0
) (
 input clk,
 input [7:0] bitpos,
 input enable_mov,
 output servo
);
 //-- ServoBit-180
 
 //-- Control de un servo Futaba 3003
 //-- con un bit. Se mueve a dos posiciones
 //-- Si enable movement está 0, el servo se mantiene en la posición "home_pos"
 //-- que se corresonden con 0 / 1
 //-- El angulo total recorrido es de 180 grados
 
 //-- ENTRADAS:
 //--  clk: Señal del sistema (12Mhz)
 //--  bitpos: Bit de posicion (0 - posicion derecha, 1 - posicion izquierda)
      
 //   Bitpos 0   Bitpos 1
 //    ___          ___
 //   | o---->  <----o |
 //   |   |        |   |
 //   |___|        |___|
 
 //-- SALIDAS:
 //-- servo : Señal PWM para controlar el servo
 
 //-- Constantes para el angulo DEL servo
 localparam ANG_0   = 8'h01;
 localparam ANG_45=8'h39;
 localparam ANG_90 = 8'h5F;
 localparam ANG_135=8'hAB;
 localparam ANG_180=8'hE0;
 localparam ANG_120=8'h5F;
 
 parameter min_angle =in_min_angle;
 parameter max_angle =in_max_angle;
 parameter home_pos=in_home_pos;
 parameter trim=in_trim;
 
 //-- Posicion del servo cuando el
 //-- bit de entrada es 0
 //-- La corona del servo mira a la derecha
 localparam BIT0 = min_angle;
 
 //-- Posicion el servo cuando el BIT
 //-- de entrada es 1
 //-- La corona del servo mira a la izquierda
 localparam BIT1 = max_angle;
 
 //--Posicion del servo neutra o home
 localparam BITH=home_pos;
 
 
 //-- Posicion de 8 bits del servo
 reg [7:0] pos;
 
 //-- Asignar la posicion de 8 bits
 //-- segun si lo recibido es 0 ó 1 o segun si el enable_mov está activado
 always @(posedge clk)
     begin
     if (enable_mov ==0)
         begin
            pos<=BITH+$signed(trim);
         end   
     else if (bitpos>BIT1)
         begin
            pos<=BIT1;
         end
     else if (bitpos<BIT0)
         begin
            pos<=BIT0;
         end
     else
         begin
             if (bitpos<=(255-trim))
                 begin
                     pos<=bitpos;
                 end
             else
                 begin
                     pos<=bitpos+$signed(trim);
                 end
         end
     end
 
 
 //always @(posedge clk)
 //  begin//pos <= bitpos ? BIT1 : BIT0;
 //    if (enable_mov ==0)
 //       pos<=BITH;
 //    else if (bitpos==0)
 //       pos<=BIT0;
 //    else
 //       pos<=BIT1;
 //  end  
   
 //---
 //--- ServoMotor 
 
 //-- M es el valor del divisor para
 //-- obtener tics de M / 12.0 micro-segundos
 localparam M = 94; 
 localparam N = $clog2(M);
 
 //-- Contador para generar los tics
 reg [N-1:0] divcounter = 0;
 
 //-- Flag para indicar que un tic
 //-- ha ocurrido
 reg tic = 0;
 
 //-- Generacion de los tics. Cada
 //-- M ciclos del reloj se genera 1
 always @(posedge clk)
  tic <= (divcounter == M - 2);
 
 //-- Contador modulo M
 always @(posedge clk)
  if (tic)
    divcounter <= 0;
  else
    divcounter <= divcounter + 1;
 
 //-- Contador de la posicion del 
 //-- servo
 reg [10:0] angle_counter = 0;
 
 //-- A la posicion destino hay que
 //-- sumarle un offset, correspondiente
 //-- a los 0.3ms de la posicion inicial
 wire [8:0] pose = {1'b0, pos} + 9'd46;
 
 //-- Con cada tic se incrementa el
 //-- contador de angulo del servo
 always @(posedge clk)
  if (tic)
    angle_counter <= angle_counter + 1;
 
 //-- Cuando el contador es menor que el 
 //-- valor objetivo, la señal de PWM
 //-- del servo se pone 1, y 0 en 
 //-- caso contrario
 
 reg servo;
 
 always @(posedge clk) begin
  servo <= (angle_counter < {2'b00, pose});
  end
 
 
 
 
endmodule

module v2003b1 #(
 parameter veca477 = 12_000_000
) (
 input vc04c2e,
 output v22d3e8
);
 localparam p2 = veca477;
 wire w0;
 wire w1;
 assign w0 = vc04c2e;
 assign v22d3e8 = w1;
 v2003b1_v3805f2 #(
  .M_in(p2)
 ) v3805f2 (
  .clk(w0),
  .clk_out(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- regular_pump_bits  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Put the a M value (12000000 by default), to control the period of the pump 
/*-------------------------------------------------*/

module v2003b1_v3805f2 #(
 parameter M_in = 0
) (
 input clk,
 output clk_out
);
 //-- module bomba_x1(input wire clk, output wire clk_1hz)
 
 //-- Bombeo de bits de periodo regular a X Hz (Dictado por M y N)
 
 //-- Constante para dividir y obtener una frecuencia de  X Hz
 parameter M = M_in;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Contador modulo M. tras M pulsos de reloj vuelve a 0
 always @(posedge clk)
   divcounter <= (divcounter == M - 1) ? 0 : divcounter + 1;
 
 //-- Obtener la señal de X Hz. La señal no tiene ciclo del 50%
 wire clk_doublehz;
 assign clk_doublehz = divcounter[N-1]; 
 
 //-- Usamos un biestable T para dividir entre 2 y obtener una señal
 //-- de X Hz y ciclo del 50%
 reg T = 0;
 always @(posedge clk_doublehz)
   T <= ~T;
   
 //-- Señal de salida de 1Hz y ciclo del 50%
 assign clk_out = T;
   
 //endmodule
endmodule

module v36d45a #(
 parameter vc5c8ea = 8'h00
) (
 output [7:0] v7d356d
);
 localparam p1 = vc5c8ea;
 wire [0:7] w0;
 assign v7d356d = w0;
 v36d45a_v465065 #(
  .V(p1)
 ) v465065 (
  .k(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- AA_8bits  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Valor constante 0xAA para bus de 8 bits
/*-------------------------------------------------*/

module v36d45a_v465065 #(
 parameter V = 0
) (
 output [7:0] k
);
 assign k = V;
endmodule

module va1b138 (
 input v21a20e,
 input [7:0] v80e965,
 input v26bbef,
 input [7:0] v71e3cf,
 input [7:0] v8071e6,
 input [7:0] v9ec8c5,
 output [7:0] vcff1aa,
 output ve29c69
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire w6;
 wire w7;
 wire [0:7] w8;
 wire [0:7] w9;
 wire [0:7] w10;
 wire [0:7] w11;
 wire w12;
 assign w4 = v21a20e;
 assign w5 = v80e965;
 assign w6 = v26bbef;
 assign w7 = v21a20e;
 assign w8 = v71e3cf;
 assign w9 = v8071e6;
 assign w10 = v9ec8c5;
 assign vcff1aa = w11;
 assign ve29c69 = w12;
 assign w7 = w4;
 v493ea8 v41e751 (
  .vcbab45(w0),
  .v0e28cb(w3),
  .v3ca442(w6)
 );
 ve543ae v38a488 (
  .v74a653(w1),
  .vc6ae1f(w2),
  .vd7ce19(w4)
 );
 v725b7e vcd26cc (
  .v9fb85f(w1)
 );
 v0ec077 v161325 (
  .v4b5bc2(w2),
  .v25ee73(w3)
 );
 va1b138_vcd2561 vcd2561 (
  .reset(w0),
  .center(w5),
  .cnt(w7),
  .sum_value(w8),
  .min_v(w9),
  .max_v(w10),
  .value(w11),
  .ow(w12)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module va1b138_vcd2561 (
 input cnt,
 input [7:0] center,
 input reset,
 input [7:0] sum_value,
 input [7:0] min_v,
 input [7:0] max_v,
 output [7:0] value,
 output ow
);
 /*
 
 Oscillator Counter
 
 
 Created by Julián Caro Linares
 
 jcarolinares@gmail.co,
 */
 
 
 
 
 reg value;
 reg c_down;
 
 
 
 always @(posedge cnt)
     
     if (reset==1)
         value<=center;
     else if (value>=max_v && c_down==0)
             c_down<=1;
     else if (value<=min_v && c_down==1)
             c_down<=0;
     else
         if (c_down==0)
             value<=value+sum_value;
         else
             value<=value-sum_value;
 
 assign ow=c_down;
endmodule

module v493ea8 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v0ec077 v1a413a (
  .v4b5bc2(w0),
  .v25ee73(w3)
 );
 v0ec077 v6168dd (
  .v4b5bc2(w1),
  .v25ee73(w4)
 );
 v4b9553 vdb792a (
  .vcbab45(w2),
  .v0e28cb(w3),
  .v3ca442(w4)
 );
endmodule

/*-------------------------------------------------*/
/*-- OR  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Puerta OR
/*-------------------------------------------------*/

module v0ec077 (
 input v4b5bc2,
 output v25ee73
);
 wire w0;
 wire w1;
 wire w2;
 assign v25ee73 = w0;
 assign w1 = v4b5bc2;
 assign w2 = v4b5bc2;
 assign w2 = w1;
 v4b9553 vdf6feb (
  .vcbab45(w0),
  .v0e28cb(w1),
  .v3ca442(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Puerta-not  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Puerta NOT
/*-------------------------------------------------*/

module v4b9553 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v4b9553_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
 v44391c vf4114c (
 
 );
 v44391c vec8c80 (
 
 );
endmodule

/*-------------------------------------------------*/
/*-- NAND  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- NAND logic gate
/*-------------------------------------------------*/

module v4b9553_vf4938a (
 input a,
 input b,
 output c
);
 // NAND logic gate
 
 assign c = ~(a & b);
endmodule

module v44391c
;
 v74d69b v949c82 (
 
 );
 v74d69b ve0f5c7 (
 
 );
endmodule

/*-------------------------------------------------*/
/*-- Transistor-mosfet  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Transistor
/*-------------------------------------------------*/

module v74d69b
;
 vef9670 vdb7477 (
 
 );
 vef9670 v826842 (
 
 );
 vef9670 vdc9b55 (
 
 );
 vef9670 vea688b (
 
 );
endmodule

/*-------------------------------------------------*/
/*-- semiconductores  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Transistor cmos hecho a partir de semiconductores
/*-------------------------------------------------*/

module vef9670
;
 v8450b0 vd09707 (
 
 );
 v8450b0 v38def6 (
 
 );
 v8450b0 v0c6e31 (
 
 );
 v8450b0 v3071e7 (
 
 );
 v8450b0 vca3873 (
 
 );
endmodule

/*-------------------------------------------------*/
/*-- Cristal-si  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Cristal de Siicio
/*-------------------------------------------------*/

module v8450b0
;

endmodule

/*-------------------------------------------------*/
/*-- Atomo-si  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Atomos de silicio
/*-------------------------------------------------*/

module ve543ae #(
 parameter v3c760f = 0
) (
 input vd7ce19,
 input v74a653,
 output vc6ae1f
);
 localparam p1 = v3c760f;
 wire w0;
 wire w2;
 wire w3;
 assign vc6ae1f = w0;
 assign w2 = vd7ce19;
 assign w3 = v74a653;
 v77050b #(
  .v38488b(p1)
 ) v767db1 (
  .vc24d9f(w0),
  .vb55943(w2),
  .vef4cea(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Biestable-D-0  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Biestable D inicializado a 0
/*-------------------------------------------------*/

module v77050b #(
 parameter v38488b = 0
) (
 input vb55943,
 input vef4cea,
 output vc24d9f
);
 localparam p3 = v38488b;
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vef4cea;
 assign w1 = vb55943;
 assign vc24d9f = w2;
 v77050b_v526aa2 #(
  .DINI(p3)
 ) v526aa2 (
  .d(w0),
  .clk(w1),
  .q(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Flip-flop D  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Biestable D con inicialización paramétrica
/*-------------------------------------------------*/

module v77050b_v526aa2 #(
 parameter DINI = 0
) (
 input clk,
 input d,
 output q
);
 // D flip-flop
 // parameter DINI = 0;
 
 reg q = DINI;
 
 always @(posedge clk)
   q <= d;
   
 
 
endmodule

module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- 0  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Un bit constante a 0
/*-------------------------------------------------*/

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
